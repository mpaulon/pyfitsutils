import datetime
import logging
import re

from decimal import Decimal
from pathlib import Path
from typing import Any, Tuple


from astropy.coordinates import Angle

from . import utils

logger = logging.getLogger()

class Fit:

    SOURCE_LEN = 7

    def block2source_dict(self, block: list[str]) -> Tuple[dict[str, str], dict[str, str]]:
        """Take a block for a measurement in a fit file an return the corresponding dictionary"""
        source_dict = {"is_main": ""}
        band_dict = {}
        for i, line in enumerate(block):
            line = line.strip()
            if line.startswith("--- ra:") and not line.endswith("pixels"):
                matches = re.search(r"(?P<value>[0-9:\.]+)\s\+\/\-\s(?P<error>[0-9\.]+)\ss", line)
                source_dict["ra"] = Angle(matches.group("value"), "hourangle")
                source_dict["ra_err"] = Angle("00:00:" + matches.group("error"), "hourangle")
            elif line.startswith("--- dec:") and not line.endswith("pixels"):
                matches = re.search(r"(?P<value>\-?[0-9\.]+)\s\+\/\-\s(?P<error>[0-9\.]+)\sarcsec", line)
                source_dict["dec"] = Angle(utils.convert_dec(matches.group("value")), "deg")
                source_dict["dec_err"] = Angle("00:00:" + matches.group("error"), "deg")
            elif line.startswith("Clean beam size"):
                matches = re.search(r"(?P<value>\-?[0-9\.]+)\sarcsec", block[i+1].strip())
                band_dict["major"] = matches.group("value")
                matches = re.search(r"(?P<value>\-?[0-9\.]+)\sarcsec", block[i+2].strip())
                band_dict["minor"] = matches.group("value")
            elif line.startswith("--- Integrated:"):
                matches = re.search(r"(?P<value>[0-9\.]+)\s\+\/\-\s(?P<error>[0-9\.]+\s[mu])Jy", line)
                if matches.group("error").endswith("u"):
                    source_dict["flux"] = Decimal(matches.group("value"))/1000
                    source_dict["flux_err"] = Decimal(matches.group("error").strip("u "))/1000
                else:                
                    source_dict["flux"] = Decimal(matches.group("value"))
                    source_dict["flux_err"] = Decimal(matches.group("error").strip("m "))
            elif line.startswith("--- frequency:"):
                matches = re.search(r"(?P<value>[0-9\.]+)\sGHz", line)
                band_dict["freq"] = matches.group("value")
        return source_dict, band_dict 

    def folder2dict(self, folder: Path) -> dict[str, Any]:
        """Take the path of a folder containing fit files and return the corresponding dict"""
        
        fits_dict = {}
        for fit_file in folder.iterdir():
            with open(fit_file) as f:
                logger.info(f"Loading fit data from {fit_file}")
                current_block = []
                for line in f:
                    line = line.strip()
                    matches = re.search(r"_(?P<date>[0-9a-zA-Z]+)_(?P<band>[A-Za-z]+)band", fit_file.as_posix())
                    fit_freq = matches.group("band")
                    fit_date = datetime.datetime.strptime(matches.group("date"), "%d%b%Y")

                    if not fits_dict.get(fit_date):
                        fits_dict[fit_date] = {
                            fit_freq: {}
                        }

                    if not fits_dict[fit_date].get(fit_freq):
                        fits_dict[fit_date][fit_freq] = {}

                    if line.startswith("Fit on"):
                        if current_block:
                            s_d, b_d = self.block2source_dict(current_block)
                            fits_dict[fit_date][fit_freq]["data"] = b_d
                            if not fits_dict[fit_date][fit_freq].get("sources"):
                                fits_dict[fit_date][fit_freq]["sources"] = []
                            fits_dict[fit_date][fit_freq]["sources"].append(s_d)
                            current_block = []
                        current_block.append(line)

                    elif current_block:
                        current_block.append(line)

                if current_block:
                    s_d, b_d = self.block2source_dict(current_block)
                    fits_dict[fit_date][fit_freq]["data"] = b_d
                    if not fits_dict[fit_date][fit_freq].get("sources"):
                        fits_dict[fit_date][fit_freq]["sources"] = []
                    fits_dict[fit_date][fit_freq]["sources"].append(s_d)

        return fits_dict

    def dict2csv(fit_dict: dict[str, Any], csv: Path):
        """Take the dict generated by fit_folder_to_dict() and write it to the specified csv"""
        logger.info(f"Saving data to {csv}")
        with open(csv, "w") as f:
            for date, bands in fit_dict.items():
                for band, data_sources in bands.items():
                    line = ",".join([
                        date.strftime("%d%b%Y"),
                        band,
                        data_sources["data"]["freq"],
                        data_sources["data"]["major"],
                        data_sources["data"]["minor"],
                        *[",".join([
                            s["ra"].to_string(sep=":"),
                            s["ra_err"].to_string(sep=":"),
                            s["dec"].to_string(sep=":"),
                            s["dec_err"].to_string(sep=":"),
                            str(s["flux"]),
                            str(s["flux_err"]),
                            str(s["is_main"]),
                        ]) for s in data_sources["sources"]]
                    ])
                    f.write(line + "\n")

    def csv2dict(self, csv: Path):
        """Return a fit dict from a specified csv"""
        with open(csv) as f:
            fits_dict = {}
            for line in f:
                line = line.strip().split(",")
                fit_date = datetime.datetime.strptime(line[0], '%d%b%Y')
                fit_freq = line[1]
                if not fits_dict.get(fit_date):
                    fits_dict[fit_date] = {
                        fit_freq: {}
                    }
                if not fits_dict[fit_date].get(fit_freq):
                    fits_dict[fit_date][fit_freq] = {}
                
                fits_dict[fit_date][fit_freq] ={
                    "data": dict(zip(["freq", "major", "minor"], line[2:5]))
                }
                fits_dict[fit_date][fit_freq]["sources"] = []
                for i in range(5, len(line[5:]), SOURCE_LEN):
                    fits_dict[fit_date][fit_freq]["sources"].append(
                        {
                            "ra": Angle(line[i], "hourangle"),
                            "ra_err": Angle(line[i+1] if ":00:" in line[i+1] else "00:00:" + line[i+1], "hourangle"),
                            "dec": Angle(line[i+2], "deg"),
                            "dec_err": Angle(line[i+3] if ":00:" in line[i+3] else "00:00:" + line[i+3], "deg"),
                            "flux": Decimal(line[i+4]),
                            "flux_err": Decimal(line[i+5]),
                            "is_main": line[i+6]
                        }
                    )
        return fits_dict

    def are_same(self, d1, d2, ignore_keys=[]):
        for key, value in d1.items():
            if key in ignore_keys:
                continue
            if d2.get(key) is None:
                return False
            if isinstance(value, Angle) and value.deg == d2.get(key).deg:
                continue
            elif isinstance(value, Decimal) and not value.compare(d2.get(key)):
                continue
            elif d2.get(key) != value:
                return False
        return True

    def merge_dicts(self, new_dict, old_dict):
        if old_dict == {}:
            return new_dict
        for date, bands in new_dict.items():
            for band, datasources in bands.items():
                new_sources = []
                for source in datasources["sources"]:
                    matching_sources = list(filter(lambda x: self.are_same(x, source, ["is_main"]), old_dict.get(date, {}).get(band, {}).get("sources", [])))
                    if len(matching_sources) == 1:

                        source["is_main"] = matching_sources[0].get("is_main", "")
                    new_sources.append(source)
                    new_dict[date][band]["sources"] = new_sources
        return new_dict

    def folders_and_csv2dict(self, csvs: list[Path], folders: list[Path]):
        assert len(csvs) == len(folders), "there should be the same amount of fit folders and csv files"
        for i, csv in enumerate(csvs):
            folder = folders[i]
            f_dict = self.folder2dict(folder) # generate fit_dict from fits txt files
            if csv.exists(): # if we have an old csv file get the is_main data
                orig_dict = self.csv2dict(csv) 
                f_dict = self.merge_dicts(f_dict, orig_dict)
            self.dict2csv(f_dict, csv) # save everything to the csv
            yield f_dict
